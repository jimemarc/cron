.. toctree::

.. highlight:: sh

===============
Developer Guide
===============


Setup Development Environment
=============================

#. Install ``pip`` and ``tox``:

   ::

      sudo apt-get install python-pip
      sudo pip install tox

#. Configure git pre-commit hook:

   ::

      sudo pip install flake8 pep8-naming
      flake8 --install-hook
      git config flake8.strict true


Building Documentation
======================

::

   tox -e doc

Output will be available at ``.tox/doc/tmp/html``. It is recommended to install
the ``webdev`` package:

::

   sudo pip install webdev

So a development web server can serve any location like this:

::

   $ webdev .tox/doc/tmp/html


Running Test Suite
==================

::

   tox -e py27,py34


Adding functions
================

Vtysh library is autogenerated from a some description dictionaries located at
via **tools/vtysh_meta.py**. In this file, the ``VTYSH_SPEC`` variable holds
all the specification of the commands the library will provide. This dictionary
is composed by *contexts*, each one containing several *commands*:

::

      'context': {
        'doc': 'Context documentation.',
        'arguments': [
            {
                'name': 'arg1',
                'doc': 'Context argument 1.'
            }
        ],
        'pre_commands': ['pre command 1', 'pre command 2 {arg1}'],
        'post_commands': ['post command'],
        'commands': [
            {
                'command': 'vtysh command {arg_a}',
                'doc': 'Documentation for the command',
                'arguments': [
                    {
                        'name': 'arg_a',
                        'doc': 'Argument for command.'
                    },
                ],
            },
            ...
         ]
      }

A *context* is a vtysh context, to get inside one a list of *pre_commands* is
run on a vtysh cli, when you are done with the context a list of
*post_commands* is executed to clean the cli.

Inside the context any number of commands can be defined. The python function
generated will be called as the vtysh command, but with underscores. This way
the first command on the example will create a function called *vtysh_command*
with *arg_a* as argument.

To add a new command to the library, a developer needs to:

#. Find if the context for the command is already defined on the dictionary.
#. If it is not defined, it has to be added.
#. Define the new command inside *commands* on the correct context.
#. Execute the generator script. To do this:

   #. Go to the ``topology_lib_vtysh`` root folder.
   #. Run ``tox`` which validates your script and prepares the py34 environment.
   #. Run ``source .tox/py34/bin/activate``.
   #. Run ``./tools/updatelib``.
   #. Run ``deactivate``.

If the vtysh command has output (by example any *show* command), a parser
function has to be defined in **parser.py**, and the function must be added to
the __all__ variable at the end of the file. The name of this function must be
"parse_<name_of_the_function>".Be aware that a function that does not belongs
to root, must have the shape "parse_<context_name>_<function_name>".
For example, if a command is "show house" a python function called "show_house"
will be autogenerated and the developer must manually define a function named
"parse_show_house" on parser.py with a description on how to parse the result
of the vtysh command. If  the command "show house" runs under the context
"Condo", the function name that must be added in parser.py must be named
"parse_condo_show_house".

Usage is described on :class:`topology_lib_vtysh.library.ContextManager`

Command and argument parameters
-------------------------------

Commands and their arguments may have parameters, they need to be set properly
in these situations:

1. Commands that return output need to have the ``returns: True`` parameter.
2. Optional command arguments need to have an ``optional: True`` parameter.

Some commands that have optional arguments may have certain arguments that are
prefixed of suffixed by a certain word. The ``prefix`` and ``suffix`` options
for those arguments can be used like this:

::

   {
       'command': 'some command',
       'doc': 'A command that does something.',
       'arguments': [
           {
               'name': 'some_argument',
               'doc': 'Some argument for the command',
               'prefix': 'some_prefix_for_the_argument ',
               'suffix': ' some_suffix_for_the_argument',
               'optional': True
           },
       ],
   },

So, if you run a test case like this one:

::

    TOPOLOGY = """
    [type=openswitch] ops1
    """


    def test_prefix(topology):
        ops1 = topology.get('ops1')

        with ops1.libs.vtysh.Configure() as ctx:
            ctx.some_command('some_argument_value')

You'll find a line similar to this one in your test logs:

::

   [ops1].send_command('some command some_prefix_for_the_argument some_argument_value some_suffix_for_the_argument', shell='vtysh') ::


Collisions between commands
...........................

It may happen that there are 2 or more vtysh commands that share the same
instructions (the actual words that make the vtysh command) but have different
types of parameters.

For example, this could be one of those cases:

- ``vtysh command ip`` where ``vtysh command`` are instructions and ``ip``
  is an argument.
- ``vtysh command group`` where ``vtysh command`` are instructions and
  ``group`` is an argument.

In that case, there must exist only one library function where its
documentation clearly explains the multiple types of parameters that it may
receive. You can find an example in the documentation for
:func:`topology_lib_vtysh.library.Configure.ip_route`.


About show-running function
...........................

The code currently is parsing only the BGP section. If an additional section
requires parsing, a new index should be added to the result dictionary, i.e.:
if vlan section parsing is to be implemented then:

#. A regex to capture only the required (vlan) section must be defined.
#. An entry to the result dictionary with vlan index should be added::

    result['vlan'] = {}

#. Any vlan related data that is parsed should be added to the vlan section
   i.e.::

       result['vlan']['vlanList'] = code_that_gets_vlan_list

#. Follow the same order that the show-running output is displayed to keep
   consistency and readability.


Adding exceptions
=================

When a commands fails (the shells gets output in a non-show command) the library
will try to determine the failure to raise a typed exception. To do so, it has
to know what kind of errors the command may show. For example::

    # asd aaa
    % Unknown command

In the above scenario, we can identify this error using a regular expression
that will match the ``% Unknown command`` output. To specify a new typed
exception edit the file ``tools/vtysh_meta.py`` and modify the
``VTYSH_EXCEPTIONS_SPEC`` dictionary mapping the name of the new exception and
a list of regular expressions for that error that will be used to try to
identify the output of a command::

    ), (
        'IncompleteCommandException',
        [
            'Command incomplete',
        ]
    )

To assert that the proper exception was raised, you can use the ``pytest``
``raises`` feature like this:

::

   from pytest import raises
   from topology_lib_vtysh.exceptions import UnknownCommandException

   TOPOLOGY = """
   [type=openswitch] ops1
   """


   def test_prefix(topology):
       ops1 = topology.get('ops1')

       with raises(UnknownCommandException):
           with ops1.libs.vtysh.ConfigVlan('8') as ctx:
               ctx.description('some wrong description')

Accessing the low-level shell API
=================================

The low-level shell API can be accessed by using the ``_shell`` and
``_shell_args`` arguments.

``_shell`` alows the user to specify the shell object who will receive the
arguments. It defaults to ``vtysh``, for obvious reasons, but this is
configurable to take into consideration nodes who may have vtysh-like shells
that are not named ``vtysh``.

``_shell_args`` is a dictionary that may contain the values specified for the
low-level shell API ``send_command`` arguments. So far, these arguments are:

#. **matches** (list): List of strings that may be matched by the shell
   expect-like mechanism as prompts in the command response.
#. **newline** (bool): True to append a newline at the end of the
   command, False otherwise.
#. **timeout** (int): Amount of time to wait until a prompt match is
   found in the command response.
#. **connection** (str): Name of the connection to be used to send the
   command. If not defined, the default connection will be used.

These arguments are prefixed with an underscore to avoid colliding with another
optional arguments a command may have.

Examples
--------

.. code-block:: python

    with ops1.libs.vtysh.ConfigInterface('8') as ctx:
        ctx.vlan_access('8', _shell_args={'timeout': 1, 'matches': [r'var']})

.. code-block:: python

    with ops1.libs.vtysh.ConfigInterface('9') as ctx:
        ctx.vlan_access(
            '8',
            _shell='pseudo_vtysh',
            _shell_args={'connection': '6'}
        )
